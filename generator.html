<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Query generator</title>
    <script src="tables.js"></script>
    <style>
        body {
            font-family: Arial;
            font-size: 10pt;
        }

        /* rc = related column */
        .rc-prev {
            color: #ccc;
        }
        .rc-past {
            color: #666;
        }
        .rc-new {
            font-weight: bold;
        }

        td {
            padding: 1em;
            vertical-align: top;
        }
        #side {
            min-width: 200px;
            overflow: scroll;
        }
        #result {
            border: 1px solid #333;
            background-color: #eee;
            padding: 2em;
        }
        #result:empty {
            display: none;
        }
        #tables {
            margin-bottom: 1em;
        }
    </style>
</head>
<body>
<table>
    <tr>
        <td id="side">
            <div id="tables"></div>
            <button onclick="createInitialTables();">Reset</button>
        </td>
        <td>
            <pre id="result"></pre>
        </td>
    </tr>
</table>

<script>
// Configuration
const __schema = 'nightbot_quiz';
const __aliasFn = function (tableName) {
    return __tables[tableName].alias;
};

// State
let __query = null;
let __pastColumns = new Set();

function createInitialTables() {
    document.getElementById('result').innerText = '';
    const tablesContainer = document.getElementById('tables');
    tablesContainer.innerHTML = '';
    __query = null;
    __pastColumns = new Set();

    for (const table in __tables) {
        const btn = document.createElement('button');
        btn.innerText = table;

        btn.addEventListener('click', () => {
            if (btn.nextElementSibling.tagName === 'UL') {
                btn.nextElementSibling.remove();
            } else {
                showInitialColumns(table, btn);
            }
        });
        btn.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            __query = { table: table };
            __pastColumns.add({
                column: null,
                table: table
            });
            showRelatedColumns(table);
            document.getElementById('result').innerText = generateQuery();
        })

        tablesContainer.appendChild(btn);
        tablesContainer.appendChild(document.createElement('br'));
    }
}

function showInitialColumns(table, btnElem) {
    for (const elem of document.querySelectorAll('ul.columns')) {
        elem.remove();
    }

    const ul = document.createElement('ul');
    ul.classList.add('columns');
    for (const col in __tables[table].columns) {
        const li = document.createElement('li');
        li.innerText = col;
        li.addEventListener('click', () => {
            createColumnFilterElem(table, col, li);
        });
        ul.appendChild(li);
    }

    btnElem.after(ul);
}

function createColumnFilterElem(table, column, colElem) {
    for (const elem of document.querySelectorAll('.where_input')) {
        elem.remove();
    }

    const inputElem = document.createElement('input');
    inputElem.type = 'text';
    inputElem.classList.add('where_input');

    const onSubmitFilter = () => {
        __query = {
            table: table,
            where: {
                column: column,
                filter: inputElem.value
            }
        };
        __pastColumns.add({
            column: column,
            table: table
        });
        showRelatedColumns(table);
        document.getElementById('result').innerText = generateQuery();
    };

    inputElem.addEventListener('keydown', (event) => {
        if (event.key === 'Enter') {
            onSubmitFilter();
        }
    });
    colElem.after(inputElem);

    const okBtn = document.createElement('button');
    okBtn.classList.add('where_input');
    okBtn.innerText = 'Go';
    okBtn.addEventListener('click', () => {
        onSubmitFilter();
    });
    inputElem.after(okBtn);
}

// Defines the CSS class name(s) when a related column is shown. You can override this function to show all
// columns the same or to have custom behavior, e.g. to check for past (table, column) combinations and not just
// past tables as is currently implemented.
function getClassForRelatedColumn(table, column, prevCol) {
    if (prevCol && prevCol.table === table && prevCol.column === column) {
        return 'rc-prev';
    }
    for (const pastColumn of __pastColumns) {
        if (pastColumn.table === table) {
            return 'rc-past';
        }
    }
    return 'rc-new';
}

function collectRelatedColumns(curTable) {
    const references = [];

    // Add references from the current table
    Object.entries(__tables[curTable].references).forEach(([sourceColumn, reference]) => {
        references.push({
            sourceTable: curTable,
            sourceColumn: sourceColumn,
            targetTable: reference.table,
            targetColumn: reference.column
        });
    });

    // Check other tables for references targeting the current table
    Object.entries(__tables).forEach(([table, definition]) => {
        if (table !== curTable) {
            Object.entries(definition.references).forEach(([targetColumn, reference]) => {
                if (reference.table === curTable) {
                    references.push({
                        sourceTable: curTable,
                        sourceColumn: reference.column,
                        targetTable: table,
                        targetColumn: targetColumn
                    });
                }
            });
        }
    });

    return references;
}

function showRelatedColumns(curTable) {
    const references = collectRelatedColumns(curTable);

    const prevCol = __query.sub
        ? {column: __query.sub.select, table: __query.sub.table}
        : null;

    const tablesContainer = document.getElementById('tables');
    tablesContainer.innerHTML = '';
    const ul = document.createElement('ul');
    tablesContainer.append(ul);

    references.forEach(ref => {
        const li = document.createElement('li');

        const btnLeftJoin = document.createElement('button');
        btnLeftJoin.innerText = 'â‹™';
        btnLeftJoin.title = 'Left join';
        btnLeftJoin.addEventListener('click', () => {
            onClickLeftJoinColumn(curTable, ref.sourceColumn, ref.targetTable, ref.targetColumn);
        });
        li.append(btnLeftJoin);

        const spanWithTableColumn = document.createElement('span');
        const cssClass = getClassForRelatedColumn(ref.targetTable, ref.targetColumn, prevCol);
        spanWithTableColumn.innerHTML = ` <span class="${cssClass}">${ref.targetTable}</span> (${ref.targetColumn})`;
        li.append(spanWithTableColumn);

        spanWithTableColumn.addEventListener('click', () => {
            onClickReferenceColumn(ref.sourceColumn, ref.targetTable, ref.targetColumn);
        });
        ul.appendChild(li);
    });
}

function showLeftJoinColumns() {
    const tables = new Set();
    tables.add(__query.table);
    for (const leftJoin of __query.leftJoin) {
        tables.add(leftJoin.sourceTable);
        tables.add(leftJoin.targetTable);
    }

    const references = [];
    tables.forEach(activeTable => {
        references.push(...collectRelatedColumns(activeTable));
    });
    Object.entries(references).forEach(([refKey, reference]) => {
        if (tables.has(reference.sourceTable) && tables.has(reference.targetTable)) {
            delete references[refKey];
        }
    });

    const tablesContainer = document.getElementById('tables');
    tablesContainer.innerHTML = '';
    const ul = document.createElement('ul');
    tablesContainer.append(ul);
    references.forEach(ref => {
        const li = document.createElement('li');

        const spanWithTableColumn = document.createElement('span');
        const cssClass = getClassForRelatedColumn(ref.targetTable, ref.targetColumn, false);
        spanWithTableColumn.innerHTML = ` <b>${ref.sourceTable}</b>.${ref.sourceColumn} &rarr; <span class="${cssClass}">${ref.targetTable}</span>.${ref.targetColumn} `;
        li.append(spanWithTableColumn);

        spanWithTableColumn.addEventListener('click', () => {
            onClickLeftJoinColumn(ref.sourceTable, ref.sourceColumn, ref.targetTable, ref.targetColumn);
        });
        ul.appendChild(li);
    });
}

function onClickLeftJoinColumn(sourceTable, sourceColumn, targetTable, targetColumn) {
    if (!__query.leftJoin) {
        __query.leftJoin = [];
    }

    __query.leftJoin.push({
        sourceTable: sourceTable,
        sourceColumn: sourceColumn,
        targetTable: targetTable,
        targetColumn: targetColumn
    });

    showLeftJoinColumns();
    document.getElementById('result').innerText = generateQuery();
}

function onClickReferenceColumn(sourceColumn, targetTable, targetColumn) {
    __query.select = sourceColumn;

    __query = {
        table: targetTable,
        whereIn: targetColumn,
        sub: __query
    };

    showRelatedColumns(targetTable);
    document.getElementById('result').innerText = generateQuery();
}

function generateQuery() {
    if (!__query) {
        return '';
    }

    return produceSql(0, __query) + ';';
}

function formatValueForWhereClause(value, table, column) {
    const columnType = __tables[table].columns[column];
    switch (columnType) {
        case 'int':
        case 'tinyint':
        case 'decimal':
            return value;
        case 'varchar':
        default: // quote by default
            return `'` + value.replaceAll('\'', '\'\'') + `'`;
    }
}

function formatTable(tableName, includeAlias) {
    const tableReference = __schema ? `${__schema}.${tableName}` : tableName;
    if (includeAlias) {
        const alias = __aliasFn(tableName);
        if (alias) {
            return tableReference + ' ' + alias;
        }
    }
    return tableReference;
}

function formatColumn(tableName, columnName, useColNameWithTable) {
    if (!useColNameWithTable) {
        return columnName;
    }

    const tableReference = __aliasFn(tableName) ?? formatTable(tableName);
    return tableReference + '.' + columnName;
}

function produceSql(level, query) {
    const indent = '    '.repeat(level);
    let result = '';
    if (query.select) {
        result += indent + 'SELECT ' + query.select;
    } else {
        result += indent + 'SELECT *';
    }

    result += '\n' + indent + 'FROM ' + formatTable(query.table, !!query.leftJoin);

    if (query.leftJoin) {
        query.leftJoin.forEach(lj => {
            result += '\n' + indent + 'LEFT JOIN ' + formatTable(lj.targetTable, true)
                + '\n' + indent + '  ON ' + formatColumn(lj.targetTable, lj.targetColumn, true)
                + ' = ' + formatColumn(lj.sourceTable, lj.sourceColumn, true);
        });
    }

    if (query.whereIn) {
        result += '\n' + indent + 'WHERE ' + formatColumn(query.table, query.whereIn, !!query.leftJoin) + ' IN (';
        result += '\n' + produceSql(level+1, query.sub);
        result += '\n' + indent + ')';
    } else if (query.where) {
        result += '\n' + indent + 'WHERE ' + formatColumn(query.table, query.where.column, !!query.leftJoin);
        if (!query.where.filter) {
            result += ' IS NULL';
        } else {
            result += ' = ' + formatValueForWhereClause(query.where.filter, query.table, query.where.column);
        }
    }
    return result;
}

createInitialTables();
</script>
</body>
</html>