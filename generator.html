<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Query generator</title>
    <script src="tables.js"></script>
    <style>
        body {
            font-family: Arial;
            font-size: 10pt;
        }

        /* rc = related column */
        .rc-prev {
            color: #ccc;
        }
        .rc-past {
            color: #666;
        }
        .rc-new {
            font-weight: bold;
        }

        td {
            padding: 1em;
            vertical-align: top;
        }
        #side {
            min-width: 200px;
            overflow: scroll;
        }
        #result {
            border: 1px solid #333;
            background-color: #eee;
            padding: 2em;
        }
        #result:empty {
            display: none;
        }
        #tables {
            margin-bottom: 1em;
        }
    </style>
</head>
<body>
<table>
    <tr>
        <td id="side">
            <div id="tables"></div>
            <button onclick="createInitialTables();">Reset</button>
        </td>
        <td>
            <pre id="result"></pre>
        </td>
    </tr>
</table>

<script>
let __query = null;
let __pastColumns = new Set();

function createInitialTables() {
    document.getElementById('result').innerText = '';
    const tablesContainer = document.getElementById('tables');
    tablesContainer.innerHTML = '';
    __query = null;
    __pastColumns = new Set();

    for (const table in __tables) {
        const btn = document.createElement('button');
        btn.innerText = table;

        btn.addEventListener('click', () => {
            if (btn.nextElementSibling.tagName === 'UL') {
                btn.nextElementSibling.remove();
            } else {
                showInitialColumns(table, btn);
            }
        });
        btn.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            __query = { table: table };
            __pastColumns.add({
                column: null,
                table: table
            });
            showRelatedTables(table);
            document.getElementById('result').innerText = generateQuery();
        })

        tablesContainer.appendChild(btn);
        tablesContainer.appendChild(document.createElement('br'));
    }
}

function showInitialColumns(table, btnElem) {
    for (const elem of document.querySelectorAll('ul.columns')) {
        elem.remove();
    }

    const ul = document.createElement('ul');
    ul.classList.add('columns');
    for (const col in __tables[table].columns) {
        const li = document.createElement('li');
        li.innerText = col;
        li.addEventListener('click', () => {
            createColumnFilterElem(table, col, li);
        });
        ul.appendChild(li);
    }

    btnElem.after(ul);
}

function createColumnFilterElem(table, column, colElem) {
    for (const elem of document.querySelectorAll('input.where_input')) {
        elem.remove();
    }

    const inputElem = document.createElement('input');
    inputElem.type = 'text';
    inputElem.classList.add('where_input');

    inputElem.addEventListener('keydown', (event) => {
        if (event.key === 'Enter') {
            __query = {
                table: table,
                where: {
                    column: column,
                    filter: inputElem.value
                }
            };
            __pastColumns.add({
                column: column,
                table: table
            });
            showRelatedTables(table);
            document.getElementById('result').innerText = generateQuery();
        }
    });

    colElem.after(inputElem);
}

// Defines the CSS class name(s) when a related column is shown. You can override this function to show all
// columns the same or to have custom behavior, e.g. to check for past (table, column) combinations and not just
// past tables as is currently implemented.
function getClassForRelatedColumn(table, column, prevCol) {
    if (prevCol && prevCol.table === table && prevCol.column === column) {
        return 'rc-prev';
    }
    for (const pastColumn of __pastColumns) {
        if (pastColumn.table === table) {
            return 'rc-past';
        }
    }
    return 'rc-new';
}

function showRelatedTables(curTable) {
    const references = [];
    const prevCol = __query.sub
        ? {column: __query.sub.select, table: __query.sub.table}
        : null;

    // Add references from the current table
    Object.entries(__tables[curTable].references).forEach(([sourceColumn, reference]) => {
        references.push({
            sourceColumn: sourceColumn,
            targetTable: reference.table,
            targetColumn: reference.column
        });
    });

    // Check other tables for references targeting the current table
    Object.entries(__tables).forEach(([table, definition]) => {
        if (table !== curTable) {
            Object.entries(definition.references).forEach(([targetColumn, reference]) => {
                if (reference.table === curTable) {
                    references.push({
                        sourceColumn: reference.column,
                        targetTable: table,
                        targetColumn: targetColumn
                    });
                }
            });
        }
    });

    const tablesContainer = document.getElementById('tables');
    tablesContainer.innerHTML = '';

    references.forEach(ref => {
        const li = document.createElement('li');
        const cssClass = getClassForRelatedColumn(ref.targetTable, ref.targetColumn, prevCol);
        li.innerHTML = `<span class="${cssClass}">${ref.targetTable}</span> (${ref.targetColumn})`;
        li.addEventListener('click', () => {
            onClickReferenceColumn(ref.sourceColumn, ref.targetTable, ref.targetColumn);
        });
        tablesContainer.appendChild(li);
    });
}

function onClickReferenceColumn(sourceColumn, targetTable, targetColumn) {
    __query.select = sourceColumn;

    __query = {
        table: targetTable,
        whereIn: targetColumn,
        sub: __query
    };

    showRelatedTables(targetTable);
    document.getElementById('result').innerText = generateQuery();
}

function generateQuery() {
    if (!__query) {
        return '';
    }

    return produceSql(0, __query) + ';';
}

function produceSql(level, query) {
    const indent = '    '.repeat(level);
    let result = '';
    if (query.select) {
        result += indent + 'SELECT ' + query.select;
    } else {
        result += indent + 'SELECT *';
    }

    result += '\n' + indent + 'FROM ' + query.table;
    if (query.whereIn) {
        result += '\n' + indent + 'WHERE ' + query.whereIn + ' IN (';
        result += '\n' + produceSql(level+1, query.sub);
        result += '\n' + indent + ')';
    } else if (query.where) {
        result += '\n' + indent + 'WHERE ' + query.where.column;
        if (!query.where.filter) {
            result += ' IS NULL';
        } else {
            result += ' = \'' + query.where.filter.replaceAll('\'', '\'\'') + '\'';
        }
    }
    return result;
}

createInitialTables();
</script>
</body>
</html>